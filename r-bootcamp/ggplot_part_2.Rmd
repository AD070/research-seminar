---
title: "Визуализация данных с помощью ggplot2, часть 2"
author: Заходякин Г.В., postlogist@gmail.com
date: 2017-09-27
output: 
  html_document: 
    toc: true
    toc_float: true
---

```{r Подключение пакетов, warning=FALSE, message=FALSE}
library(tidyverse)
library(forcats) # работа с факторами
library(scales) # процентный формат для осей на графике
```



# Введение

Это вторая часть блокнота по пакету визуализации `ggplot2`. Этот пакет реализует концепцию **грамматики графики**, которая позволяет описать, как получить любую визуализацию на основе данных с помощью нескольких простых действий. В [первой части](ggplot_part_1.Rmd) мы рассмотрели базовые элементы грамматики:  

  - геометрические объекты (**geom**),  
  - визуальные характеристики этих объектов - эстетики (**aesthetics**), 
  - а также связывание (**mapping**) данных и эстетик. 
  
Часто визуализация требует предварительной обработки данных с помощью некоторой статистической функции (**stat**) - например, при построении гистограммы нужна группировка данных на интервалы и подсчет частот.
  
![Путь от данных к графику в ggplot2](pics/mapping_stat.png)

Детали отображения данных на визуальные характеристики настраиваются при помощи шкал (**scales**). Например, шкалы позволяют задать соответствие цветов и категорий в данных, установить нужный порядок категорий, применить нелинейное преобразование, чтобы сделать зависимость более явной, избавиться от выбросов, ограничив диапазон выводимых данных...

Шкалы помещают данные в некоторую систему координат. Чтобы ее показать на экране, применяются функции для работы с координатными системами (**coord**). Например, вы можете поменять местами оси координат, чтобы сделать подписи на графике более читаемыми.

Также мы рассмотрели еще один способ для оценки влияния категориальной переменной - разделение на панели (*faceting*).


Шаблон кода для построения графиков выглядит так:

```
ggplot(data = <DATA>) +
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>)) +
  ... +
  <SCALE_FUNCTION> +
  <FACET_FUCTION> +
  <COORD_FUNCTION>

```
Практический пример:

```{r Пример графика с разделением на панели и настройкой шкал}
data(mpg)
head(mpg)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class)) +
  scale_color_brewer(palette = 'Accent') + 
  scale_y_sqrt() +
  facet_wrap(~drv, scales = 'free_x') +
  labs(title = 'Зависимость топливной эффективности от объема двигателя')

```


В этой части будет рассмотрена работа со слоями, а также вопросы визуализации категориальных данных.





# Слои

**Слои** (**layers**) позволяют комбинировать на одной визуализации различные представления данных.  Например, тренды, опорные линии, метки наблюдений и аннотации могут быть добавлены на одну визуализацию как отдельные слои.

Чтобы добавить новые слои, вы можете включить в код для построения графика любое количество функций `geom_...()` или `stat_...()`:


```
ggplot(data = <DATA>) +
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>)) +
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>)) +
  <STAT_FUNCTION>(mapping = aes(<MAPPINGS>)) +
  ...
  
```

Каждый слой может иметь свой набор соответствий между столбцами таблицы данных и эстетиками. При этом, если какие-то соответствия - одни и те же для нескольких слоев, то удобно вынести их из определения слоя в вызов функции `ggplot()`. В этом случае придется задавать соответствие только один раз.



## Пример: добавление линии тренда на график

Построим визуалиазацию зависимости топливной эффективности от размера двигателя для машин с разным типом привода.

```{r Пример графика с трендом}

ggplot(data = mpg, 
       mapping = aes(x = displ, y = hwy)) + # общие для всех слоев связи
  geom_point(mapping = aes(color = drv)) + # x и y уже заданы, добавляем цвет
  geom_smooth(method = 'lm', se = FALSE) # x и y уже заданы

```

Здесь данные заданы в `ggplot()`, поэтому они используются всеми слоями. Две связи - для эстетик `x` и `y` - также заданы сразу для всех слоев, поэтому в `geom_point()` добавляется только связь для цвета, а в `geom_smooth()` вообще не требуется задавать никаких связей.


## Упражнение: добавление трендов для подгрупп

Используя набор данных `diamonds`:

```{r Загрузка данных diamonds}
data(diamonds)
head(diamonds)
```

Напишите код, в точности воспроизводящий следующий график:

![Упражнение - добавление трендов](pics/diamonds_trends.png)

**Совет:** вы можете открыть график в новом окне, кликнув по ссылке на него с нажатой клавшией `Shift`. Если RStudio жалуется на отсутствующий файл, - выполните команду меню: `Session/Set Working Directory/To Source File Location`, чтобы установить в качестве рабочей директории папку, в которой находится данный блокнот.


```{r Упражнение - тренды для подгрупп}
# Раскомментируйте и допишите код:

#ggplot(data = diamonds, ...) +
#  geom_point(...) +
#  geom_smooth(...)

```

**Подсказки:** 
  - По умолчанию `geom_smooth()` будет строить нелинейные тренды, такие же как на этом графике.   - Чтобы тренд строился на всем диапазоне оси x, используйте аргумент `fullrange = TRUE` для `geom_smooth()`.
  
  
## Пример: выделение элементов на графике

В `ggplot2`, к сожалению, нет возможности интерактивно исследовать данные на визуализации, но можно понять, где находятся наблюдения с интересующими свойствами при помощи аннотаций. В качестве примера, выделим на графике все автомобили марки 'dodge':

```{r Пример аннотирования графиков при помощи слоев}
ggplot(data = mpg, 
       mapping = aes(x = displ, y = hwy)) + 
  
  geom_point(data = 
               filter(mpg, manufacturer == 'dodge'), 
             color = 'white', size = 5) +
  
  geom_point(mapping = aes(color = class)) +
  
  geom_smooth(se = FALSE)
```

**Примечания:**  
  - связи по умолчанию задаются в `ggplot()`, поэтому в последующих слоях не требуется связывать с данными эстетики `x` и `y`;  
  - самый первый слой на графике использует свой, отдельный набор данных - таблицу, в которой отфильтрованы данные только по автомобилям `dodge`;  
  - остальные слои используют данные, заданные в `ggplot()`;  
  - порядок слоев важен, иначе более крупные точки закрывали бы более мелкие.


## Пример: добавление опорных линий

На визуализациях полезно добавлять опорные линии. Например, таким образом можно показать, где находится центр распределения. Для добавления опорных линий используются функции `geom_hline()` и `geom_vline()`.

```{r Пример опорной линии}
ggplot(data = mpg) + 
  geom_histogram(mapping = aes(x = hwy), 
                 binwidth = 2)  +
  
  geom_vline(mapping = 
               aes(xintercept = median(hwy),
                   color = 'Медианный пробег'),
             show.legend = TRUE) +
  
  labs(color = NULL)

```


**Примечания:**  
  - положение линии задается эстетикой `xintercept`;  
  - желательно использовать для нее связывание, а не определение, т.к. внутри функции `aes()` у вас есть доступ к именам столбцов в таблице данных для графика;  
  - по умолчанию опорные линии не включаются в легенду, здесь мы явно потребовали это сделать.


## Пример: сравнение гистограммы и теоретического распределения

Чтобы проверить, соответствуют ли данные какому-либо теоретическому распределению - например, нормальному или экспоненциальному, полезно сравнить гистограмму или плотность распределения с кривой теоретического распределения. Как это сделать, - смотрите в блокноте [ggplot_plotting_functions.Rmd](ggplot_plotting_functions.Rmd).






# Корректировка положения объектов (position adjustment)

## Проблема наложения данных (overplotting)

Часто встречается ситуация, когда данные в таблице приводятся с ограниченной точностью. Например, при описании возраста его обычно округляют до года. В нашем примере про автомобили округлены пробег на галлоне и объем двигателя.

Из-за дискретности значений, визуализация не позволяет правильно оценить, где сконцентрированы данные. Точки накладываются и закрывают друг друга. Один из способов борьбы с наложением (**overplotting**) - использование прозрачности.


```{r Пример наложения данных}
# Исходный график с наложением
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))

# Прозрачность делает точки видимыми
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy), 
             alpha = 0.2)

```


## Добавление шума к данным (jitter)

Существует и другой способ борьбы с наложением данных - можно сделать совпадающие точки видимыми, если добавить к данным небольшой случайный шум. Это можно сделать прямо в процессе визуализации, поскольку `ggplot2` позволяет вносить изменения в расположение объекта (**position adjustments**).

```{r График с добавлением шума}

ggplot(data = mpg,
       mapping = aes(x = displ, y = hwy)) +
  
  geom_point(position = 'jitter',
             color = 'lightskyblue') +

  geom_point(alpha = 0.2)
  

```


Поскольку добавление шума с целью сделать данные видимыми - распространенный прием, в `ggplot2` для удобства сделана отдельная функция - `geom_jitter()`: 


```{r Displpacement vs mileage with geom_jitter}

ggplot(data = mpg,
       mapping = aes(x = displ, y = hwy)) +
  
  geom_jitter(color = 'lightskyblue') +

  geom_point(alpha = 0.2)

```



Корректировка положения полезна и для других типов геомов. С применением этой функции для столбиковых диаграмм вы познакомитесь в следующем разделе.




  Диаграммы рассеяния

изменение шкалы с помощью coord_trans()


Условные средние - считают через dplyr. Функции filter, group_by, mutate, arrange

Нарисовать среднее по возрастной группе как geom_line
Потом - то же самое с помощью stat_summary:
geom_line(stat = 'summary', fun.y=mean)
Дорисовать квантили (fun.y = quantile, probs = .1)
Связь двух переменных на scatterplot vs отличие этих переменных на гистограмме
График временного ряда
Шум в данных: влияние периода усреднения на шум
Loess
Сильное сглаживание неправильно передает тренд
ГРафики для распространения надо выбирать тщательно
Может быть явная зависимость (временной ряд), но нулевая корреляция уровня со временем
Тренировались в расчете возраста в дробных годах на основе номера дня рождения и возраста
Как гладкость графика зависит от интервала усреднения
geom_smooth()

ggplot2. stat_summary(). все про столбики. факторы. hline/vline. слои, 


