---
title: "Исследование структуры временных рядов в R (практика)"
author: "Заходякин Г.В., postlogist@gmail.com"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = 'svg', warning = FALSE) 
# выбор векторного формата для графиков и отключение жалоб на русские шрифты на графиках
```


# Введение

В этом блокноте разобран пример анализа регулярного временного ряда из базы данных ВШЭ Sophist с использованием метода классической декомпозиции (базовый R) и STL-декомпозиции (пакет `forecast`).


```{r Подключение библиотек}
suppressMessages(library(tidyverse)) # ggplot2 и трансформация данных
suppressMessages(library(forecast)) # анализ временных рядов и прогнозирование
suppressMessages(library(ggfortify)) # Визуализация временных рядов с помощью ggplot2
suppressMessages(library(sophisthse)) # Загрузка временных рядов из базы Sophist
suppressMessages(library(stringr))  # Работа с текстовыми строками

suppressMessages(library(scales)) # Форматирование осей на графиках ggplot2
suppressMessages(library(lubridate)) # обработка дат
suppressMessages(library(ggseas)) # Расширения ggplot для временных рядов
```


# Как загрузить данные из Sophist

Для автоматической загрузки данных из БД Sophist можно использовать пакет [`sophisthse`](https://CRAN.R-project.org/package=sophisthse), разработанный Борисом Демешевым.
В дистрибутив для курса этот пакет включен. Если вы самостоятельно устанавливали R, то убедитесь в том, что у вас этот пакет установлен. Как обычно, пакет из CRAN можно установить командой `install.packages()`.

Главная функция пакета - `sophisthse()` - загружает многомерные временные ряды, т.е. таблицы. Чтобы загрузить временной ряд, надо знать название соответствующего показателя. Вы можете узнать имена показателей в самой базе данных - см. http://sophist.hse.ru/hse/nindex.shtml.

Например, открыв таблицу http://sophist.hse.ru/exes/tables/RTRD_M_I.htm, можно узнать, что показатель:  `Оборот розничной торговли в текущих ценах` называется `RTRD_M`.

Другой способ - просмотр встроенного в пакет списка показателей (`series_info`)


```{r Список показателей в пакете sophisthse}
head(series_info, n = 10)
```

Заметим, что название показателя для загрузки содержится в столбце `tsname`, а расшифровка - в столбце `fullname`.

Можно искать показатель в таблице, используя поиск по шаблону строки (`stringr::str_detect()`). В простейшем случае шаблон - это искомая подстрока. Более сложные шаблоны (регулярные выражения) описаны в книге [R for data science](http://r4ds.had.co.nz/strings.html) - см. раздел 14.1.


```{r Поиск нужного показателя}
series_info %>% 
  filter(str_detect(fullname, 'розн')) %>% 
  select(fullname, tsname, unit)
```


При указании имени показателя загружается вся таблица, в которой он содержится.

```{r Загрузка ряда}
retail <- sophisthse('RTRD_M')
head(retail)
```


Посмотреть описание загруженных данных:

```{r Метаданные}
sophisthse_metadata(retail)

```


Полученный объект имеет тип многомерного временного ряда (`mts`) и матрицы (`matrix`).

```{r Тип объекта}
class(retail)
```

Извлечь нужный столбец можно по индексу. Рекомендуем использовать имена столбцов, а не номера, чтобы избежать ошибок при изменении числа столбцов в таблице.

```{r Извлечение столбца}

# Извлечение столбца
rtrd <- retail[, 'RTRD_M']

# Тип объекта для одномерного ряда
class(rtrd)

# Вывод значений
rtrd

```

Таблица даже с единственным столбцом имеет тип многомерного ряда, поэтому может потребоваться "извлечь" оттуда столбец по индексу, чтобы с ним могли работать функции для прогнозирования и визуализации.

В начале ряда есть пропущенные значения. Чтобы удалить их, отберем наблюдения начиная с января 1995 года

```{r Отбор наблюдений}
rtrd <- window(rtrd, start = c(1995, 1))
```


# Анализ временного ряда

## Визуализация

Для построения графиков нам потребуются подписи для заголовка и осей. Их можно задать вручную, но можно и извлечь из метаданных ряда.

```{r Подписи для графика из метаданных ряда}
# Метка и единица измерения
rtrd_info <- sophisthse_metadata(retail) %>%
  filter(tsname == 'RTRD_M') %>%
  select(fullname, unit)

rtrd_label <- rtrd_info$fullname
rtrd_unit <- rtrd_info$unit
```

Функции базовой графики R могут работать с временными рядами `ts` непосредственно. Для визуализации временного ряда средствами `ggplot2` необходимо загрузить пакет `ggfortify`. График создается функцией `autoplot()`. В результате получается объект, с которым можно продолжить работу стандартными средствами `ggplot2`.

```{r Визуализация}
autoplot(rtrd, ts.colour = 'lightskyblue') +
  labs(y = rtrd_unit, 
       title = rtrd_label)
```

Справку по функции можно получить командой: `?ggfortify::autoplot.ts`.
Описание с примерами: http://rpubs.com/sinhrks/plot_ts.

## Классическая сезонная декомпозиция

Декомпозиция временного ряда позволяет выделить отдельные его компоненты - тренд, сезонность и нерегулярные изменения (остаток). 

Форма графика временного ряда позволяет предположить наличие тренда и сезонных колебаний мультипликативного типа.

Вначале воспользуемся встроенной функцией R - `decompose()`, реализующей метод классической декомпозиции на основе скользящего среднего. Визуализировать результаты можно с помощью функции `autoplot()`

```{r Классическая декомпозиция}

rtrd_d <- decompose(rtrd, type = 'multiplicative')

autoplot(rtrd_d, ts.colour = 'lightskyblue') +
  labs(title = 'Компоненты временного ряда (классическая декомпозиция)')

```

Результат декомпозиции имеет множество применений, например:

 - Легче сравнивать временные ряды, если исключить сезонные изменения.
 - Легче выявлять нерегулярные изменения, не укладывающиеся в регулярные сезонные колебания.
 - Можно скомбинировать компоненты, чтобы получить прогноз.
 - После исключения сезонности и/или тренда из временного ряда результат можно описать с помощью более простой модели. Получив прогноз с помощью более простой модели, можно "вернуть" исключенные компоненты. 
 - Данные о сезонности гораздо более устойчивы, чем данные о тренде. Это может быть полезно при прогнозировании в кризисный период: сезонность сохраняется, а направление тренда резко изменяется из-за спада в экономике.


```{r Компоненты объекта при использовании классической декомпозиции}
names(rtrd_d)
```

Здесь `x` - исходный ряд, `seasonal` и `trend` - закономерные компоненты, `random` - остаток.

Рассмотрим отдельно компоненты ряда. Для сравнения, будем изображать компоненты поверх исходного ряда

**Тренд**

```{r Тренд}
autoplot(cbind(rtrd, rtrd_d$trend)) + 
  scale_colour_manual(labels = c('Ряд', 'Тренд'),
                      values = c('lightskyblue', 'red')) +
  labs(y = NULL, color = 'Обозначения')
```

Обратим внимание на то, что линия тренда короче исходного ряда. Это вызвано тем, что функция `decompose()` использует для выделения тренда скользящее среднее с окном, равным частоте временного ряда (12). В результате, по 6 периодов в начале и в конце ряда теряются, т.к. скользящее окно усреднения выходит в эти периоды за пределы данных и среднее не может быть вычислено.

На графике виден спад во время кризисов 2008 и 2015 года.

**Сезонный компонент**

```{r Сезонный компонент}
autoplot(rtrd_d$seasonal) +
  labs(y = NULL, title = 'Сезонные коэффициенты') +
  scale_x_date(date_minor_breaks = 'years')
```

В методе классической декомпозиции сезонные коэффициенты получаются с помощью усреднения наблюдений для одноименных месяцев после удаления тренда, поэтому наборы сезонных коэффициентов для всех лет одинаковы.

**Модель ряда**

Модель ряда получается путем сочетания выделенных закономерных компонентов. Сравним результат с исходными данными.

```{r Модель ряда}
autoplot(cbind(rtrd, rtrd_d$trend * rtrd_d$seasonal)) + 
  scale_colour_manual(labels = c('Ряд', 'Модель ряда'),
                      values = c('lightskyblue', 'dodgerblue')) +
  labs(y = NULL, color = 'Обозначения')
```

Результат близок к оригиналу, однако виды расхождения. Эти расхождения - **остатки**, или ошибки модели. Их также называют нерегулярным (случайным) компонентом ряда.

**Остатки**

```{r Нерегулярный компонент}
autoplot(rtrd_d$random) +
  labs(y = NULL, title = 'Нерегулярный компонент ряда') +
  scale_x_date(date_minor_breaks = 'years')
```

Заметны регулярные колебания остатков, следовательно, закономерные компоненты исключены не полностью. Это - следствие того, что на протяжении выбранного для анализа периода величина сезонных коэффициентов менялась, но классическая декомпозиция не позволила этого учесть. Следовательно, необходимо использовать другой метод и/или сократить количество наблюдений.

## Сезонная корректировка ряда

Сезонная корректировка ряда позволяет исключить влияние сезонных колебаний. Это облегчает анализ краткосрочных изменений ряда, которые иначе не видны из-за сезонности. Для выполнения сезонной корректировки в R можно использовать функцию `forecast::seasadj()`. Эта функция принимает в качестве аргумента объект, созданный одной из функций для декомпозиции.

```{r Сезонная корректировка}
rtrd_adj <- seasadj(rtrd_d)

autoplot(cbind(rtrd, rtrd_d$trend, rtrd_adj)) + 
  scale_colour_manual(labels = c('Ряд', 'Тренд', 'СС ряд'),
                      values = c('lightskyblue', 'red', 'brown')) +
  labs(y = NULL, color = 'Обозначения')

```

В отличие от сильно сглаженной линии тренда, график сезонно-скорректированный ряд содержит случайные колебания уровня. Наш ряд имеет мультипликативную структуру, поэтому его модель может быть описана формулой:

$$ y = T \cdot S \cdot E, $$

где $T$ - тренд, $S$ - сезонный коэффициент, $E$ - случайная (нерегулярная) составляющая, или ошибка, $y$ - наблюдаемое значение ряда.

Тренд - это только компонент $T$, а ряд с исключенной сезонностью получается с помощью деления:

$$ A = \frac{y}{S} = T \cdot E. $$

В отличие от тренда, десезонализованный временной ряд содержит случайную составляющую $E$.


Аналогичного результата можно добиться и с помощью непосредственного деления исходного ряда на сезонные коэффициенты:

```{r Сезонная корректировка вручную}

autoplot(cbind(rtrd, rtrd_adj, rtrd/rtrd_d$seasonal)) + 
  scale_colour_manual(labels = c('Ряд', 'СС ряд, seasadj()', 'СС ряд, расчет'),
                      values = c('lightskyblue', 'brown', 'orange')) +
  labs(y = NULL, color = 'Обозначения')

```

Ряд с исключенной сезонностью содержит значения во всех периодах, т.к. для его вычисления используются непосредственно значения исходного ряда и сезонные коэффициенты. Сезонные коэффициенты - одни и те же для всех лет временного ряда, поэтому проблемы потери данных нет.


## Исключение тренда

Подобным же образом, можно удалить из ряда тренд, чтобы облегчить анализ изменений сезонного цикла.


```{r Удаление тренда}
rtrd_detrended <- rtrd/rtrd_d$trend

autoplot(rtrd_detrended, ts.colour = 'green') +
  labs(y = NULL, title = 'Ряд с удаленным трендом') +
  scale_x_date(date_minor_breaks = 'years')

```

В пакете `forecast` имеется функция для визуализации отличий сезонных колебаний в разные годы - `ggseasonplot()`. 

```{r График сезонных циклов}
ggseasonplot(rtrd_detrended)
ggseasonplot(window(rtrd_detrended, start = 2007))
```

## STL-декомпозиция

Теперь выполним декомпозицию, используя функцию `forecast::stl()` (*Seasonal and Trend decomposition using Loess*). Данная функция также выделяет тренд с помощью сглаживания, но использует вместо скользящего среднего метод локальной регрессии - LOESS. Это позволяет исключить  потерю данных на концах ряда. Кроме того, метод более устойчив к выбросам в данных ряда. 

Недостатком этого подхода является поддержка сезонности только аддитивного типа. Большинство экономических временных рядов - мультипликативные. 

Для решения этой проблемы можно либо разрешить сезонным компонентам ряда постепенно меняться (используя параметр `s.window` функции `stl()`), либо преобразовать данные, чтобы превратить мультипликативный характер сезонности в аддитивный.

### Изменяющиеся сезонные коэффициенты

Обязательный параметр `s.window` функции `stl()` задает ширину окна для сглаживания ряда методом LOESS при извлечении сезонного компонента. Значение параметра должно быть нечетным и не менее 7. Также можно задать `s.window = 'periodic'`, тогда набор сезонных коэффициентов будет одним и тем же для всех лет.

```{r Подбор ширины окны сглаживания}

# Ширина окна сглаживания w задается в цикле
for (w in c(7, 9, 11, 15, 19)) {
  p <- autoplot(stl(rtrd, s.window = w), ts.colour = 'lightskyblue') + 
    labs(title = paste('s.window =', w))
  print(p)
}

```

Увеличение ширины окна сглаживания снижает скорость изменения сезонного компонента, однако это приводит к появлению сезонных колебаний в остатках модели.

Остановимся на компромиссной ширине окна 9.

```{r STL-декомпозиция с изменяющимися сезонными коэффициентами}
rtrd_stl <- stl(rtrd, s.window = 9)
```

Исследуем структуру полученного объекта (см. `?stl`).

```{r Структура объекта после STL-декомпозиции}
# Имена
names(rtrd_stl) 
```

Компоненты ряда хранятся внутри вложенного объекта `time.series`, включающего 3 столбца - `seasonal`, `trend` и `remainder`.

```{r Компоненты ряда после STL-декомпозиции}
window(rtrd_stl$time.series, start = 2016)
```

Этот объект - многомерный ряд `mts`, для извлечения нужного столбца используйте индекс.

```{r График нерегулярного компонента}

autoplot(rtrd_stl$time.series[,'remainder']) +
  labs(title = 'Покупательские подвиги во время кризисов') +
  scale_x_date(date_breaks = 'year', 
               date_minor_breaks = 'year',
               date_labels = '%y')
```

Сезонная корректировка ряда позволяет увидеть эти пики в масштабе исходных данных.

```{r Сезонная корректировка ряда методом STL}
autoplot(cbind(rtrd, seasadj(rtrd_stl))) +
  scale_colour_manual(labels = c('Ряд', 'СС ряд'),
                      values = c('lightskyblue', 'brown')) +
  labs(y = NULL, color = 'Обозначения', title = rtrd_label)
```

### Логарифмирование

 Другой способ обойти проблему мультипликативной сезонности - преобразование данных. При логарифмировании произведение компонент ряда заменяется на сумму логарифмов:

$$ y = T \cdot S \cdot E \Rightarrow  \log y = \log T + \log S + \log E $$

```{r График ряда после логарифмирования}
autoplot(log10(rtrd), ts.colour = 'darkgray') +
  labs(title = 'Десятичный логарифм оборота розничной торговли')
```


Аддитивная лучше подходит к преобразованным данным. Неудобство при данном подходе в том, что для визуализации компонентов в исходном масштабе необходимо обратное преобразование - вычисление показательной функции. Также этот метод не применим, когда в исходных данных содержатся нули.

```{r STL-декомпозиция логарифмированного ряда}
log_rtrd_stl <- stl(log10(rtrd), s.window = 'periodic')
autoplot(log_rtrd_stl, ts.colour = 'lightskyblue')
```

Чтобы сравнить модель ряда с исходными данными, необходимо выполнить обратное преобразование компонентов ряда - $10^x$.

```{r Сравнение оригинального ряда и модели}

rtrd_stl_fit <- 10^(log_rtrd_stl$time.series[,'trend'] + 
                    log_rtrd_stl$time.series[,'seasonal'])

autoplot(cbind(rtrd, rtrd_stl_fit)) + 
  scale_colour_manual(labels = c('Ряд', 'Модель ряда'),
                      values = c('lightskyblue', 'dodgerblue')) +
  labs(y = NULL, color = 'Обозначения')

```

### Преобразования Бокса-Кокса

Помимо логарифмирования, можно применять и другие преобразования ряда, чтобы уменьшить зависимость амплитуды колебаний от уровня ряда. Например, применяются **степенные преобразования** (**power transformations**):  

$$w_t = y_t ^ {p},$$


где $$p \in \{\frac{1}{2}, \frac{1}{3}, -1 \}. $$


Бокс и Кокс предложили удобный способ описания целого семейства преобразований, включающего степенные преобразования и логарифмирование с помощью параметра $\lambda$. 

**Преобразование Бокса-Кокса** (**Box-Cox transformation**) задается следующим образом:

$$
 w_t = 
  \begin{cases} 
   \log{y} &   \text{при } \lambda = 0 \\
   (y_t^\lambda - 1) / \lambda & \text{иначе.}
  \end{cases}
$$

Логарфм используется натуральный.

Для преобразования временных рядов в R имеется функция `forecast::BoxCox()`.

```{r Преобразования Бокса-Кокса}
# Параметр преобразования изменяется в цикле
for (lambda in c(-2, -1, 0, 0.25, 0.5, 1, 1.5)) {
  p <- autoplot(BoxCox(rtrd, lambda), ts.colour = 'lightskyblue') + 
    labs(title = paste('lambda = ', lambda))
  print(p)
}

```

Аналогичный пример, демонстрирующий влияние параметра $\lambda$, можно посмотреть [здесь](https://www.otexts.org/sites/default/files/fpp/images/telec.gif)

Для автоматического подбора $\lambda$, при котором преобразованный ряд наиболее близок к аддитивной сезонной модели, можно использовать функцию `forecast::BoxCox.lambda()`. О применяемых методах подбора параметра $\lambda$ можно прочитать в справке.

```{r Автоматический подбор параметра преобразования Бокса-Кокса}

best_lambda <- BoxCox.lambda(rtrd)

autoplot(BoxCox(rtrd, best_lambda), ts.colour = 'lightskyblue') + 
    labs(title = paste('lambda = ', round(best_lambda, 2)))

```

Полученное в результате подбора значение параметра можно использовать в качестве ориентира, поскольку дробные значения $\lambda$ затрудняют интерпретацию данных. Например, $\lambda = 0.42$ лучше заменить на $\lambda = 0.5$ (квадратный корень).

В данном случае значение параметра $\lambda$ близко к нулю, следовательно для преобразования лучше всего применять логарифмирование.

Чтобы перейти от преобразованных данных назад к исходным, необходимо применить обратное преобразование (**back-transform**). Математически **обратное преобразование Бокса-Кокса** (**reverse Box-Cox transformation**) задается следующим образом:

$$
 y_t = 
  \begin{cases} 
   \exp(w_t) &   \text{при } \lambda = 0 \\
   (\lambda w_t + 1) ^ \frac{1}{\lambda}  & \text{иначе.}
  \end{cases}
$$

В R для обратного преобразования Бокса-Кокса используется функция `forecast::InvBoxCox()`.

При использовании преобразований Бокса-Кокса помните о следующих его особенностях:

- При наличии во временном ряде отрицательных или нулевых значений преобразование невозможно. Однако можно прибавить константу ко всем значения ряда, чтобы исключить отрицательные значения.
- Выбирайте легко интерпретируемые значения $\lambda$ (0.37 -> 0.33, или кубический корень).
- Методы прогнозирования слабо чувствительны к изменению параметра $\lambda$
- Часто преобразование не требуется
- Преобразование иногда практически не изменяет точечный прогноз, но сильно влияет на доверительные интервалы для прогноза.

# Задание

**1. Познакомьтесь с функциями, входящими в пакет `sophisthse`**

Посмотрите краткую "шпаргалку" по основным возможностям пакета. Для этого выполните следующий блок кода или откройте [ссылку](https://github.com/bdemeshev/sophisthse/blob/master/vignettes/sophisthse_intro.Rmd). 



```{r}
#vignette('sophisthse_intro') # Раскомментируйте перед запуском
```

**Виньетки** (**vignette**) - это вид документации в R, в котором кратко объясняется основная функциональность пакета.


Посмотрите, какие функции входят в пакет `sophisthse`, выполнив следующий блок кода.

```{r}
#help(package = sophisthse) # Раскомментируйте перед запуском
```


**2. Загрузите экономические показатели из базы Sophist**

Используя пакет `sophisthse`, загрузите данные по следующим показателям:
 - Индекс производства С. Добыча полезных ископаемых (IP_CEA_M)
 - Индекс производства D. Обрабатывающие производства (IP_DEA_M) 
 - Индекс реального оборота розничной торговли (RTRD_M_DIRI)
 
 
 
**3. Приведите показатели к одному базису**
```{r}

```

Базисный период для индексов IP_CEA_M и IP_DEA_M - январь 2002 года. Для индекса розничной торговли - январь 1994 года. Чтобы сделать показатели сопоставимыми, пересчитайте значения индекса RTRD_M_DIRI так, чтобы величина этого показателя в январе 2002 года была равна 100.  

После этого сократите глубину истории по показателю RTRD_M_DIRI так, чтобы ряд начинался с января 2002 года.

```{r}

```


**4. Визуализация показателей**

Постройте график, отображающий динамику показателей

```{r}

```

Какой тип сезонности присутствует в этих временных рядах?

**5. Сезонная декомпозиция**

Выполните сезонную декомпозицию рядов, используя метод STL с изменяющимися сезонными коэффициентами.

```{r}

```


**6. Сравнение динамики показателей**

Постройте график, на котором сравнивается динамика сезонно-скорректированных показателей.

```{r}

```


Постройте график, на котором сравниваются тренды показателей

```{r}

```


Постройте график, на котором сравниваются нерегулярные компоненты показателей

```{r}

```

**Ответьте на вопросы:**

Какой из графиков нагляднее показывает отличие в реакции показателей на экономические кризисы 2008 и 2014 года?

Какая из отраслей быстрее всего реагирует на кризис? 

Для какой из отраслей этот эффект наиболее выраженный?

Какая из отраслей быстрее всего восстанавливалась после кризиса 2008 года?

Отличается ли поведение показателей в кризисах 2008 и 2014 года?


**7. Преобразования данных**

Подберите наилучшее значение параметра $\lambda$ преобразования Бокса-Кокса для каждого показателя. При необходимости, скорректируйте значение параметра для обеспечения простой интерпретации преобразованных данных.

Повторите сезонную декомпозицию методом STL, на этот раз используя фиксированный набор сезонных коэффициентов (`s.window = 'periodic'`) и преобразованные данные.


Получите модель каждого ряда (сумма тренда и сезонного компонента). Затем постройте три графика, на каждом из которых в сравнивается исходный (непреобразованный) показатель и модель. Для перевода данных модели в шкалу исходного показателя используйте функцию `InvBoxCox()`.
