---
title: "Методы экспоненциального сглаживания"
author: "Заходякин Г.В., postlogist@gmail.com"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_depth: 3
---

```{r Настройка, include=TRUE}
knitr::opts_chunk$set(dev = 'png', warning = FALSE) 
# выбор формата для графиков и отключение жалоб на русские шрифты на графиках
options(digits = 4) # Количество значащих цифр при выводе
```

```{r Подключение библиотек}
suppressMessages(library(tidyverse)) # ggplot2 и трансформация данных
suppressMessages(library(forecast)) # анализ временных рядов и прогнозирование
suppressMessages(library(ggfortify)) # Визуализация временных рядов с помощью ggplot2
suppressMessages(library(scales)) # Форматирование осей на графиках ggplot2
suppressMessages(library(fpp)) # Примеры временных рядов
suppressMessages(library(sophisthse)) # Загрузка временных рядов из базы Sophist

suppressMessages(library(stringr))  # Работа с текстовыми строками
suppressMessages(library(lubridate)) # обработка дат
suppressMessages(library(ggseas)) # Расширения ggplot для временных рядов
```

# Введение

Методы экспоненциального сглаживания начиная с середины XX века широко применяются для анализа временных рядов и прогнозирования в технике и управлении. Применение методов экспоненциального сглаживания для прогнозирования включает два этапа: сначала на основе имеющихся данных получают оценки для закономерных компонентов ряда - уровня, скорости роста (тренда) и сезонных коэффициентов. Затем, комбинируя наиболее свежие оценки закономерных компонентов ряда, строится прогноз на будущее. Оценки закономерных компонентов при получении новых данных корректируются с использованием ошибки прогноза на текущем шаге и **константы сглаживания**, которая задает долю от величины ошибки, которая будет использоваться для корректировки прогноза. На рисунке показана схема работы метода простого экспоненциального сглаживания.

![Схема метода простого экспоненциального сглаживания](pics/error-correction.png)

Сглаженное значение на шаге $t$ определяется по формуле:

$$ L_t = L_{t-1} + \alpha (y_t - L_{t-1}) = L_{t-1} + \alpha e_t $$

Своим названием методы обязаны тому, что при развертывании рекуррентной формулы, приведенной выше, прошлые наблюдения получают экспоненциально затухающие веса:

$$ 
  L_t = L_{t-1} + \alpha (y_t - L_{t-1}) = \alpha y_t + L_{t-1} (1 - \alpha) = \\
    \alpha y_t + \alpha (1 - \alpha) y_{t-1} + (1 - \alpha)^2 L_{t-2} = \\
    \alpha y_t + \alpha (1 - \alpha) y_{t-1} + \alpha (1 - \alpha)^2 y_{t-2} + (1 - \alpha)^3 L_{t-3} 
$$

Поскольку $\alpha < 1$, наиболее свежие наблюдения получают большие веса, чем более давние наблюдения.

```{r Коэффициенты в методе простого экспоненциального сглаживания}
# Значение константы сглаживания
a <- 0.5
# Коэффициенты
i <- 0:9
coefs <- a * (1 - a)^i
# Визуализация
ggplot(tibble(x = factor(i), y = coefs)) +
  geom_bar(aes(x, y), stat = 'identity', fill = 'lightskyblue', width = 0.25) + 
  labs(title = paste('Веса прошлых наблюдений при alpha = ', a),
       x = 'Лаг', y = 'Вес наблюдения')

```

Методы экспоненциального сглаживания позволяют быстро получать прогнозы для широкого спектра временных рядов и способны адаптироваться к изменению закономерных компонентов ряда. Это сделало их одним из наиболее популярных и успешных подходов при разработке инструментов автоматизированного прогнозирования.

В этом блокноте будут рассмотрены классические методы экспоненциального сглаживания - простое экспоненциальное сглаживание, метод Хольта и метод Винтерса.

Материал составлен на основе главы [7](https://www.otexts.org/fpp/7) 
книги: *Hyndman R, Athanasopoulos G. Forecasting Principles and Practice*.


# Простое экспоненциальное сглаживание

Метод **простого экспоненциального сглаживания** (*simple exponential smoothing, SES*) позволяет выделить лишь среднее значение временного ряда - **уровень** (*Level*). Для получения этого компонента используется формула:

$$ L_t = y_t \cdot \alpha + L_{t-1} \cdot (1 - \alpha), $$

где $\alpha \in [0, 1]$ - константа сглаживания, которая определяет скорость реакции уровня ряда $L$ на изменения в наблюдаемых значениях $y$. Чем больше $\alpha$, тем быстрее уровень реагирует на изменения и тем меньше сглаживание. 

При $\alpha = 0 $ обновление уровня не происходит при изменении $y$, сохраняется начальное значение уровня - $L_1$.

Первоначальное значение уровня - $L_1$ необходимо задать (**инициализировать**).

При прогнозировании в методе простого экспоненциального сглаживания применяется наивный подход, предполагающий, что все последующие наблюдения будут такими же, как и последнее значение уровня:

$$ \hat{y}_{T+h} = L_{T} =const $$

По этой причине простое экспоненциальное сглаживание может применяться для прогнозирования только временных рядов, в которых нет выраженного тренда или сезонности, либо рядов, из которых эти компоненты были удалены.

## Пример

Рассмотрим работу метода на примере ежемесячных продаж новых частных домов в США (см.`?hsales`).
Метод реализован функцией `forecast::ses()` (см. `?ses`)

```{r Модель простого экспоненциального сглаживания}
hs90 <- window(hsales, start = 1990)
hs90_label <- 'Ежемесячные продажи новых частных домов в США'

# Прогноз на 24 месяца
hs90_fit <- ses(hs90, h = 24)

# Константа сглаживания и начальное значение уровня подбираются автоматически по критерию минимизации суммы квадратов ошибок прогноза на 1 шаг

# Сводка по модели
summary(hs90_fit)

```

```{r Структура объекта}
# Структура объекта, возвращаемого функцией ses():
names(hs90_fit)
```

Полезные имена компонентов:
 - `fitted` - прогноз на 1 шаг в историческом периоде;
 - `mean` - прогноз на будущее;
 - `model$states` - компоненты ряда  в историческом периоде (в методе простого экспоненциального сглаживания - только уровень).


```{r Получение параметров модели}
# Как добраться до параметров
hs90_fit$model$par
best_alpha <- hs90_fit$model$par['alpha']
```

```{r График прогноза - простое ЭС}

autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_fit$model$states,
               'Прогноз' = hs90_fit$mean)) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения') +
  annotate(geom = 'text', x = 1997, y = 47, 
           label = paste('alpha =', round(best_alpha, 2)))

```

Рассмотрим, как влияет константа сглаживания на результат.

```{r Влияние константы сглаживания}
fit1 <- ses(hs90, alpha = 0.1, h = 24)
fit2 <- ses(hs90, alpha = 0.4, h = 24)

autoplot(cbind('Ряд' = hs90,
               'Уровень, alpha = 0.2' = fit1$model$states,
               'Уровень, alpha = 0.4' = fit2$model$states,
               'Прогноз, alpha = 0.2' = fit1$mean,
               'Прогноз, alpha = 0.4' = fit2$mean)) +
  labs(title = hs90_label, x = NULL, y = NULL, color = 'Обозначения') +
  scale_color_manual(values = c('lightskyblue', 'darkgreen', 'orange', 'green', 'gold'))

```


## Задание

1. Загрузите из EАЭСД (sophist) ряд с годовыми показателями численности населения России (`POPNUM_Y`).
2. Используя метод простого экспоненциального сглаживания, постройте прогноз численности населения на 5 лет (константу сглаживания не задавайте, она будет подобрана автоаматически).
3. Выведите и проанализируйте сводку по модели (`summary()`):
   - Чему равна константа сглаживания? 
   - Интерпретируйте показатели ошибки.
4. Визуализируйте прогноз и значения уровня ряда в историческом периоде.
5. Попробуйте задать несколько различных значений константы сглаживания. Как это влияет на уровень ряда и прогноз?
6. Можно ли доверять прогнозу? Почему?

```{r Задание - прогноз численности населения}

```

# Метод Хольта (с линейным трендом)

В методе Хольта с помощью экспоненциального сглаживания выделяются два закономерных компонента ряда - **уровень** (*Level*) и **скорость роста** (*Trend*):

$$ L_t = y_t \cdot \alpha + (L_{t-1} + b_{t-1})\cdot (1-\alpha) $$

$$ b_t = (L_t - L_{t-1}) \cdot \beta + b_{t-1} \cdot (1-\beta) $$

Для прогнозирования используются последние значения уровня и скорости роста ряда:

$$ \hat{y}_{T+h} = L_{T} + h \cdot b_T $$

## Пример
В R метод Хольта реализован функцией `forecast::holt()`.

```{r Модель Хольта}
# Прогноз на 24 месяца
hs90_holt <- holt(hs90, h = 24) 
# Константы сглаживания и начальное значение уровня и тренда подбираются автоматически

# Сводка по модели
summary(hs90_holt)

```


```{r График прогноза - метод Хольта}

autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_holt$model$states[,'l'],
               'Прогноз' = hs90_holt$mean)) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

```

```{r Компоненты ряда - метод Хольта}
autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_holt$model$states[, 'l'],
               'Тренд' = hs90_holt$model$states[, 'b']), 
         facets = T) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

```


Модель с минимальной ошибкой на обучающем периоде - не обязательно лучшая. В данном случае очевидно, что компоненты ряда плохо адаптируются к данным из-за неудачно подобранных констант. Зададим константы вручную.

```{r Метод Хольта, подбор констант вручную}
# Прогноз на 24 месяца
hs90_holt_man <- holt(hs90, alpha = 0.2, beta = 0.05, h = 24) 
# Начальное значение уровня и тренда подбираются автоматически, константы заданы вручную

# Компоненты ряда
autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_holt_man$model$states[, 'l'],
               'Тренд' = hs90_holt_man$model$states[, 'b']), 
         facets = T) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

# Прогноз
autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_holt_man$model$states[,'l'],
               'Прогноз' = hs90_holt_man$mean)) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')


```


## Задание

1. Продолжите работу с годовыми показателями численности населения России (`POPNUM_Y`). Используя метод Хольта, постройте прогноз численности населения на 5 лет (константы сглаживания не задавайте, они будет подобрана автоаматически).
2. Выведите и проанализируйте сводку по модели (`summary()`):
   - Чему равны константа сглаживания? 
   - Интерпретируйте показатели ошибки и сравните их с ошибками метода простого экспоненциального сглаживания.
3. Визуализируйте прогноз и значения уровня ряда в историческом периоде.
4. Попробуйте задать несколько различных значений констант сглаживания. Как это влияет на компоненты ряда и прогноз?
5. Можно ли доверять прогнозу? Почему?

```{r Задание - прогноз численности населения методом Хольта}

```


# Метод Винтерса
Метод Винтерса позволяет учитывать как скорость изменения ряда, так и сезонность. Существует две модификации модели Винтерса, в зависимости от типа сезонности, - мультипликативная и аддитивная модели.


## Мультипликативная модель Винтерса

В мультипликативной модели Винтерса компоненты выделяются по формулам:

$$ L_t = \left( \frac{y_t}{S_{t-m}} \right) \cdot \alpha + (L_{t-1} + b_{t-1})\cdot (1-\alpha) $$

$$ b_t = (L_t - L_{t-1}) \cdot \beta + b_{t-1} \cdot (1-\beta) $$

$$ S_t = \frac{y_t} {L_t} \cdot \gamma + S_{t-m} \cdot (1-\gamma) $$
Здесь $m$ - длина сезонного цикла.

Для прогнозирования используется уравнение:

$$ \hat{y}_{T+h} = (L_{T} + h \cdot b_T) \cdot S_{T-m+h} $$


## Пример

В R мультипликативная модель Винтерса реализуется функцией `forecast::hw()` с параметром `seasonal = 'multiplicative')`.

```{r Мультипликативная модель Винтерса}
# Прогноз на 24 месяца
hs90_winters_m <- hw(hs90, h = 24, seasonal = 'multiplicative') 
# Константы сглаживания и начальное значение уровня и тренда подбираются автоматически

# Сводка по модели
summary(hs90_winters_m)

```


```{r График прогноза - мультипликативная модель Винтерса}

autoplot(cbind('Ряд' = hs90, 
               'Подгонка' = hs90_winters_m$fitted,
               'Прогноз' = hs90_winters_m$mean)) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

```

```{r Компоненты ряда - мультипликативная модель Винтерса}
autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_winters_m$model$states[, 'l'],
               'Тренд' = hs90_winters_m$model$states[, 'b'],
               'Сезонность' = hs90_winters_m$model$states[, 's1']),       
         facets = T) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

```


## Аддитивная модель Винтерса

В аддитивной модели Винтерса компоненты выделяются по формулам:

$$ L_t = ( y_t - S_{t-m} ) \cdot \alpha + (L_{t-1} + b_{t-1})\cdot (1-\alpha) $$

$$ b_t = (L_t - L_{t-1}) \cdot \beta + b_{t-1} \cdot (1-\beta) $$

$$ S_t = (y_t - L_t) \cdot \gamma + S_{t-m} \cdot (1-\gamma) $$


Для прогнозирования используется уравнение:

$$ \hat{y}_{T+h} = (L_{T} + h \cdot b_T) + S_{T-m+h} $$


## Пример

В R аддитивная модель Винтерса реализуется функцией `forecast::hw()` с параметром `seasonal = 'additive')`.

```{r Аддитивная модель Винтерса}
# Прогноз на 24 месяца
hs90_winters_a <- hw(hs90, h = 24, seasonal = 'additive') 
# Константы сглаживания и начальное значение уровня и тренда подбираются автоматически

# Сводка по модели
summary(hs90_winters_a)

```

```{r График прогноза - аддитивная модель Винтерса}

autoplot(cbind('Ряд' = hs90, 
               'Подгонка' = hs90_winters_a$fitted,
               'Прогноз' = hs90_winters_a$mean)) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

```

```{r Компоненты ряда - аддитивная модель Винтерса}
autoplot(cbind('Ряд' = hs90, 
               'Уровень' = hs90_winters_a$model$states[, 'l'],
               'Тренд' = hs90_winters_a$model$states[, 'b'],
               'Сезонность' = hs90_winters_a$model$states[, 's1']),       
         facets = T) +
  labs(title = hs90_label, y = NULL, x = NULL, color = 'Обозначения')

```


## Сравнение аддитивной и мультипликативной моделей

### Визуальное сравнение

```{r Визуальное сравнение двух моделей}

autoplot(cbind('Ряд' = hs90,
               'Подгонка, мульт.' = hs90_winters_m$fitted,
               'Подгонка, адд.' = hs90_winters_a$fitted,
               'Прогноз, мульт.' = hs90_winters_m$mean,
               'Прогноз, адд.' = hs90_winters_a$mean)) +
  labs(title = hs90_label, x = NULL, y = NULL, color = 'Обозначения') +
  scale_color_manual(values = c('lightskyblue', 'darkgreen', 'orange', 'green', 'gold'))
```


### Сравнение параметров

```{r Параметры мультипликативной модели}
# Мультипликативная модель
hs90_winters_m$model$par[1:3]
```


```{r Параметры аддитивной модели}
# Аддитивная модель
hs90_winters_a$model$par[1:3]
```

### Сравнение ошибок на обучающем периоде

```{r Сравнение ошибок двух моделей}
acc <- rbind(accuracy(hs90_winters_m), 
             accuracy(hs90_winters_a))

rownames(acc) <- c('Мульт. модель', 'Адд.модель')
acc
```


## Задание

1. Загрузите из EАЭСД (sophist) ряд с месячными показателями индекса пассажирооборота транспорта общего пользования (`TRP_M_PASS_DIRI`).
2. Визуализируйте ряд и изучите структуру его закономерных компонентов. Когда наблюдаются периоды повышенного спроса на пассажирские перевозки? Чем это обусловлено? Какой это тип сезонности?
3. Как кризисы повлияли на тренд пассажироооборота? Что при этом произошло с сезонным компонентом?
4. На основе ваших выводов о структуре ряда, выберите подходящую модель прогнозирования.
5. Надо ли ограничивать глубину исторического периода при построении модели, или следует взять все данные?
6. Методом Ex-Post прогнозирования сравните 2-3 варианта модели, различающиеся типом сезонности и/или значениями констант. В качестве тестового периода используйте последние 12 месяцев от имеющихся данных. Сравнение необходимо провести визуальным методом и с помощью показателей ошибок. 
7. Выберите лучшую модель и постройте модель с такими же параметрами, использующую актуальные данные о пассажирообороте (т.е. теперь тестовый период исключать не нужно). С помощью полученной модели сделайте прогноз пассажирооборота на 2 года вперед.

