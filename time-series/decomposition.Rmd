---
title: "Исследование структуры временных рядов в R"
author: "Заходякин Г.В., postlogist@gmail.com"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = 'svg', warning = FALSE) 
# выбор векторного формата для графиков и отключение жалоб на русские шрифты на графиках
```


# Введение

В этом блокноте рассмотрены понятие временного ряда и компонентов временного ряда. Показано использование доступных в R инструментов для исследования структуры временных рядов.


```{r Подключение библиотек}
suppressMessages(library(tidyverse)) # ggplot2 и трансформация данных
suppressMessages(library(zoo)) # Поддержка высокочастотных рядов
suppressMessages(library(forecast)) # анализ временных рядов и прогнозирование
suppressMessages(library(lubridate)) # обработка дат
suppressMessages(library(scales)) # Форматирование осей на графиках ggplot2
suppressMessages(library(ggseas)) # Расширения ggplot для временных рядов
suppressMessages(library(ggfortify)) # Визуализация временных рядов с помощью ggplot2
suppressMessages(library(fpp)) # Примеры временных рядов
suppressMessages(library(sophisthse)) # Загрузка временных рядов из базы Sophist

```

# Понятие временного ряда

**Временной ряд** (*time series*) - последовательность наблюдений некоторого процесса, зафиксированных в определенные моменты времени. С помощью анализа временных рядов можно прогнозировать развитие различных процессов во времени (продажи, заказы, цены, информационные и материальные потоки).

Многие методы анализа и прогнозирования временных рядов требуют, чтобы наблюдения временного ряда были выполнены через одинаковые интервалы времени (*regular intervals*), например ежегодно, ежеквартально, ежемесячно, еженедельно, ежедневно, ежечасно. **Нерегулярные временные ряды** (*irregular time series*) распростространены в естественных науках, технике, биржевой торговле, но в этом курсе такие ряды не будут рассматриваться подробно.

**Прогнозирование временных рядов** (*time series forecasting*) направлено на оценку будущих значений временного ряда на основе выделения в исторических данных закономерных компонентов (*regular components*), при этом, как правило ставится как задача оценки ожидаемых будущих значений (*point estimation*), так и задача оценки степени неопределенности, свяазанной с прогнозами (*interval estimation*).

Закономерные компоненты временного ряда включают:

- **тренд** (*trend*) - постепенное, долгосрочное изменение среднего уровня ряда;
- **сезонность** (*seasonality*) - регулярные изменения уровня ряда, происходящие в определенные периоды (например, сезонное увеличение продаж потребительских товаров перед новогодними праздниками, повышенный спрос на прохладительные напитки в летний период). Сезонные изменения повторяются в определенном цикле (например, годовом, недельном или суточном). Длительность (количество периодов) этого цикла считается известной и неизменной.

Кроме того, временные ряды могут содержать и другие компоненты:

- **Циклы** (*сyclic*) - периоды подъема и спада, не имеющие четко выраженной периодичности. Как правило, такие изменения связаны с крупномасштабными изменениями в экономике и имеют долгосрочный характер (годы). Не следует путать эти колебания с сезонностью, циклы не связаны с определенными периодами года. При анализе временных рядов циклы обычно "сливаются" с трендом.

- **Нерегулярный компонент**, или **остаток** (*irregular component*, *error*, *residual*)  - все остальные колебания, не учтенные закономерными компонентами.

## Примеры временных рядов

```{r График продаж электроэнергии}

autoplot(elecsales, ts.colour = 'lightskyblue') +
  labs(y = 'ГВт-ч', 
     title = 'Ежегодные продажи электроэнергии бытовым потребителям\n (Австралия)')

```

```{r График продаж односемейных домов}

autoplot(hsales, ts.colour = 'lightskyblue') +
  labs(y = 'млн', 
     title = 'Ежемесячные продажи новых частных домов (США)')

```

```{r График производства электроэнергии}
autoplot(elec, ts.colour = 'lightskyblue') +
  labs(y = 'ГВт-ч', 
     title = 'Ежемесячное производство электроэнергии (Австралия)')
```

```{r График производства электронного оборудования}
autoplot(elecequip, ts.colour = 'lightskyblue') +
  labs(y = 'Индекс (2005=100)', 
     title = 'Ежемесячный индекс производства\nэлектронного оборудования (16 стран ЕС)') 

```

```{r График производства пива}
autoplot(ausbeer, ts.colour = 'lightskyblue') +
  labs(y = 'мегалитры', 
     title = 'Ежеквартальный объем производства пива (Австралия)')
```

```{r График курса Евро}
euro <- read.zoo('data/euro.tsv', 
                 format = '%d.%m.%Y', head = T, dec = ',')

# Для объектов zoo синтаксис отличается, см. ?autoplot.zoo
autoplot(euro, colour = I('lightskyblue')) +
  labs(y = 'руб/Евро', x = NULL,
     title = 'Курс Евро') +
  scale_x_date(date_breaks = '1 month',
               date_minor_breaks = '1 week')

# График курса за месяц
autoplot(window(euro, start = as_date('2016-10-01')), 
         colour = I('lightskyblue')) +
  labs(y = 'руб/Евро', x = NULL,
     title = 'Курс Евро') +
  scale_x_date(date_breaks = '1 week',
               date_minor_breaks = '1 day')

```


```{r График рождаемости}

babies <- read.zoo('data/babies.tsv', 
                   format = '%d.%m.%Y', head=T)

# График за 2 года
autoplot(window(babies, start = as_date('1988-01-01')), 
         colour = I('lightskyblue')) +
  labs(y = 'число новорожденных', x = NULL,
     title = 'Ежедневные данные о рождаемости (один из штатов Канады)') +
  scale_x_date(date_minor_breaks = '1 month')

# График за 1 месяц
autoplot(window(babies, 
                start = as_date('1988-09-01'), 
                end = as_date('1988-09-30')), 
         colour = I('lightskyblue')) +
  labs(y = 'число новорожденных', x = NULL,
     title = 'Ежедневные данные о рождаемости (один из штатов Канады)') +
  scale_x_date(date_minor_breaks = '1 day', date_breaks = '1 week',
               date_labels = '%d.%m.%y (%a)')

# Коды форматов дат - см. ?strptime

```

# Методы анализа временных рядов

## Сглаживание 

Временные ряды со значительным случайным компонентом сложно анализировать, т.к. закономерности поведения ряда теряются в шумах. Чтобы упростить анализ закономерных компонент, применяются методы **сглаживания** временных рядов (*smoothing*). Сглаживание подавляет случайные колебания и позволяет лучше видеть тренд.

Одним из наиболее простых методов сглаживания является **скользящее среднее** (*moving average*). Например, каждое наблюдение ряда можно заменить средним значением, включающим это и два соседних наблюдения раньше и позже данного. Такой способ вычисления соответствует **центрированному скользящему среднему порядка 3** (*centered moving average of order 3*).

![Центрированное скользящее среднее](pics/centered_ma.jpg)

Формула для расчета центированного скользящего среднего:

$$ MA_t = \frac{ y_{t-q} + \ldots + y_t + \ldots + y_{t+q} } {2q-1} $$

Здесь $MA_t$ - сглаженное значение для периода $t$,  а порядок $k = 2q + 1$ - количество усредняемых значений ряда. Для центрированного скользящего среднего порядок должен быть нечетным (odd).

Центрированное скользящее среднее невозможно вычислить для первых и последних $q$ наблюдений, т.к. окно сглаживания (*smoothing window*) для этих периодов выходит за пределы данных.

Увеличение порядка усиливает степень сглаживания и сокращает количество наблюдений

```{r Влияние порядка сглаживания}

autoplot(cbind('Оригинал' = elecsales,
               'СС 3' = ma(elecsales, order = 3),
               'СС 7' = ma(elecsales, order = 7))) +
  labs(y = 'ГВт-ч', x = NULL,
     title = 'Ежегодные продажи электроэнергии бытовым потребителям\n (Австралия)',
     color = 'Ряд') +
  scale_color_manual(values = c('lightskyblue', 'orange', 'red'))


```

Эффект сглаживания в наибольшей степени проявляется в высокочастотных временных рядах. Этот метод может использоваться для выделения тренда.


```{r Выделение тренда с помощью скользящего среднего}

babies88 <- window(babies, start=as_date('1988-01-01'))
                   
autoplot(cbind('Оригинал' = babies88,
               '3-месячное СС' = rollmean(babies88, 91)),
         facets = NULL) + # Это функция для ряда zoo 
  scale_color_manual(values = c('lightskyblue', 'red')) +
  labs(y = 'число новорожденных', x = NULL,
       title = 'Ежедневные данные о рождаемости\n(один из штатов Канады)',
       color = 'Ряд')

```

С помощью пакета `ggseas` можно вычислять другие функции для сглаживания рядов, например, скользящую медиану.

```{r Выделение тренда с помощью скользящей медианы}

ausbeer_df <- tsdf(ausbeer) # Преобразовать ряд в датафрейм

ggplot(ausbeer_df, aes(x, y)) + 
  geom_line(aes(color = 'Оригинал')) +
  stat_rollapplyr(width = 12, 
                  FUN = median, 
                  align = 'center', aes(color = 'Медиана')) +
  labs(y = 'мегалитры', 
       title = 'Ежеквартальный объем производства пива (Австралия)',
       color = 'Ряд') +
  scale_color_manual(values = c('red', 'lightskyblue'))
```

## Декомпозиция временных рядов

Временной ряд можно рассматривать как совокупность трех компонентов - тренд-циклического (*trend-cycle*), сезонного (*seasonal*) и нерегулярного (*irregular*). Для описания ряда можно использовать либо **аддитивную**:

$$ y_t = S_t + T_t + E_t, $$

либо **мультипликативную** модель:

$$ y_t = S_t \cdot T_t \cdot E_t. $$

Аддитивная модель применяется если амплитуда сезонных и случайных колебаний не увеличивается с увеличением среднего уровня ряда. Если же амплитуда колебаний пропорциональна среднему уровню, то необходимо использовать мультипликативную модель ряда.

Если мультипликативную модель использовать невозможно (например, ее не поддерживает инструмент анализа данных), то можно преобразовать данные, чтобы исключить эффект увеличения амплитуды колебаний с ростом уровня. Одним из способов добиться этого эффекта является логарифмирование:

$$ y_t = S_t \cdot T_t \cdot E_t \Rightarrow 
    \log y_t = \log S_t + \log T_t + \log E_t $$
    
### Классическая сезонная декомпозиция

В методе **классической сезонной декомпозиции** (*classical decomposition*) для выделения тренда используется центрированное скользящее среднее. Это приводит к потере данных на концах временного ряда. 

Рассмотрим этот метод на примере мультипликативного временного ряда.

1. Вычисляется центрированное скользящее среднее с порядком не менее длины сезонного цикла. В результате получается оценка тренда $\hat{T}$.

2. Из данных исключается тренд: $y_t / \hat{T_t}$.

3. Определяется сезонный индекс для каждого месяца, для этого усредняются наблюдения для этого месяца с удаленным трендом. Например, при расчете сезонного индекса для октября необходимо усреднить все наблюдения за этот период в разные годы (после удаления тренда).

4. Сезонные индексы корректируются, чтобы их среднее значение было равно 1.

5. Выделяется нерегулярный компонент путем деление на тренд и сезонный индекс для соответствующего периода:
  
  $$ \hat{E_t} = y_t / (\hat{T_t} \cdot \hat{S_t}). $$

В случае аддитивного ряда алгоритм аналогичен, за исключением шагов 2 и 5, где вместо деления используется вычитание. Корректировка сезонных индексов производится таким образом, чтобы их сумма была равна 0.

```{r Сезонный график}
ggmonthplot(elec) +
labs(y = 'ГВт-ч', 
     title = 'Ежемесячное производство электроэнергии (Австралия)')
```


```{r Классическая декомпозиция мультипликативного ряда, warning=F}

elec_d <- decompose(elec, type = 'multiplicative')
autoplot(elec_d, ts.colour = 'lightskyblue')

# Структура объекта
str(elec_d)

autoplot(cbind('Оригинал' = elec,
               'Тренд' = elec_d$trend,
               'Модель ряда' = elec_d$trend * elec_d$seasonal)) +
  labs(y = 'ГВт-ч', x = NULL,
     title = 'Ежемесячное производство электроэнергии (Австралия)',
     color = 'Ряд') +
  scale_color_manual(values = c('lightskyblue', 'red', 'green'))

autoplot(elec_d$random, ts.colour = 'darkgray') +
  labs(y = NULL, x = NULL,
     title = 'Нерегулярный компонент ряда')

```


```{r Классическая декомпозиция аддитивного ряда, warning=F}

elecequip_d <- decompose(elecequip, type = 'additive')

autoplot(elecequip_d, ts.colour = 'lightskyblue')

autoplot(cbind('Оригинал' = elecequip,
               'Тренд' = elecequip_d$trend,
               'Модель ряда' = elecequip_d$trend + elecequip_d$seasonal)) +
  labs(y = 'Индекс (2005=100)', x = NULL,
       title = 'Ежемесячный индекс производства\nэлектронного оборудования (16 стран ЕС)', 
       color = 'Ряд') +
  scale_color_manual(values = c('lightskyblue', 'red', 'green'))

autoplot(elecequip_d$random, ts.colour = 'darkgray') +
  labs(y = NULL, x = NULL,
     title = 'Нерегулярный компонент ряда')
```

## STL-декомпозиция

Недостатком метода классической декомпозиции является потеря данных на концах ряда из-за использования скользящего среднего. В R реализован один из методов, позволяющих преодолеть этот недостаток - метод **STL-декомпозиции** (*Seasonal and Trend decomposition using Loess*). [Loess](https://en.wikipedia.org/wiki/Local_regression) - это метод основанный на регрессии метод сглаживания, который используется для выявления нелинейных зависимостей.

Преимущества STL-декомпозиции:

- нет потери данных на концах ряда

- может использоваться с любой длительностью сезонного цикла, поддерживаются не только месяцы, кварталы или недели

- сезонный компонент может со временем изменяться

- метод устойчив к выбросам (*robust*), если пользователь выбрал соответствующий параметр. В этом случае нетипичные наблюдения не используются для оценки тренд-циклической компоненты и попадают в остаток.

Недостком реализации этого метода в R является невозможность использования с мультипликативными временными рядами. Однако ряд можно сделать аддитивным с помощью логарифмирования.

```{r STL-декомпозиция аддитивного ряда}

elecequip_sd <- stl(elecequip, s.window = 'periodic')
#параметр: s.window='periodic' делает сезонные коэффициенты постоянными

autoplot(elecequip_sd, ts.colour='lightskyblue',
     main = 'STL-декомпозиция аддитивного ряда')
```

```{r STL-декомпозиция мультипликативного ряда 1}
# Попытка #1 - разрешаем сезонному компоненту постепенно меняться
elec_sd <- stl(elec, s.window = 7)

autoplot(elec_sd, ts.colour='lightskyblue',
     main = 'STL декомпозиция мультипликативного ряда')
```

```{r STL-декомпозиция мультипликативного ряда 2}
# Попытка #2 -логарифмирование данных
elec_sd2 <- stl(log(elec), s.window = 'periodic')

autoplot(elec_sd2, ts.colour='lightskyblue',
     main = 'STL декомпозиция мультипликативного ряда, логарифмирование')

```



```{r Структура объекта после STL-декомпозиции}
# Имена
names(elecequip_sd) 

# Компоненты ряда хранятся внутри вложенного объекта time.series 
head(elecequip_sd$time.series, 3)  # Это матрица, а не список, $ не работает, используйте []
```

```{r График с компонентами после STL-декомпозиции}
# Все компоненты на одном графике
autoplot(cbind('Оригинал' = elecequip,
               'Тренд' = elecequip_sd$time.series[,'trend'],
               'Модель ряда' = 
                 elecequip_sd$time.series[,'trend'] +
                 elecequip_sd$time.series[,'seasonal'])) +
  labs(y = 'Индекс, 2005 = 100', x = NULL,
     title = 'Ежемесячное производство электронного оборудования',
     color = 'Ряд') +
  scale_color_manual(values = c('lightskyblue', 'red', 'green'))


autoplot(elecequip_sd$time.series[,'remainder'], ts.colour = 'darkgray') +
  labs(y = NULL, x = NULL,
     title = 'Нерегулярный компонент ряда')

```

Если при декомпозиции мультипликативного ряда применялось логарифмирование, то получить данные в исходном масштабе можно с помощью обратного преобразования: $$ log ^{-1}(x) \equiv exp(x).$$


## Сезонная корректировка

**Сезонная корректировка** (*seasonal adjustment*) исключает сезонный компонент ряда. Полученный ряд будет содержать только тренд и нерегулярный компонент. В зависимости от применяемой модели ряда, производится деление на сезонные индексы, или вычитание этих индексов.

Аддитивная модель:

$$ A_t = y_t - \hat{S_t} = T_t + E_t.$$

Мультипликативная модель:

$$ A_t = y_t / \hat{S_t} = T_t \cdot E_t.$$

Сезонная корректировка применяется для упрощения анализа трендов при визуализации или моделировании данных. 

В R сезонная корректировка реализована в нескольких пакетах. Например, можно использовать функцию `forecast::seasadj()`. 

```{r Сезонная корректировка ряда}
ausbeer_sd <- stl(ausbeer, s.window = 7, t.window = 21)
ausbeer_sas <- seasadj(ausbeer_sd)

autoplot(cbind('Оригинал' = ausbeer,
               'Тренд' = ausbeer_sd$time.series[,'trend'],
               'Скорректированный ряд' = ausbeer_sas)) +
  
  labs(y = 'мегалитры', x = NULL,
     title = 'Ежеквартальный объем производства пива (Австралия)',
     color = 'Ряд') +
  scale_color_manual(values = c('lightskyblue', 'red', 'orange'))

```

Другая возможность - использование пакета `ggseas` [см. здесь](http://ellisp.github.io/blog/2016/03/28/ggseas-update) и [здесь](https://github.com/ellisp/ggseas).


# Задание
Изучите краткую инструкцию по работе с пакетом [sophisthse](https://cran.r-project.org/web/packages/sophisthse/vignettes/sophisthse_intro.html).

Загрузите из базы данных sophist любой ежемесячный временной ряд.

Исследуйте закономерные компоненты этого ряда.

Нарисуйте на одной системе координат ряд, тренд для этого ряда, сезонно-скорректированный ряд.
