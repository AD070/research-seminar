---
title: "Workflow Basics"
author: "Gleb V. Zakhodyakin"
date: '27.09.2016'
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The big picture
A typical data analysis project includes the following steps:

![Workflow](http://r4ds.had.co.nz/diagrams/data-science-explore.png)

R and RStudio help make your analysis *reproducible*. This means that each step you take to get the results from the raw data is recorded in a script of Rmarkdown file. You can always return, make changes and reiterate.

To enable a solid workflow, follow the set of simple *rules*:

1. Create a separate folder for each new data analysis project.

2. Keep all data files there (you can structure your project using subfolders).

3. Keep scripts (RMarkdown files) there. Put all the steps required to get the results in the script. The best way to check if the analysis runs as intended is to *knit* your file to html/doc/html notebook.

4. If saving some outputs is required, put them into the project's folder.

RStudio has a convenient feature called RStudio projects that helps you manage files for your project. Read about it [here](http://r4ds.had.co.nz/workflow-projects.html#rstudio-projects).


# The working directory

R has a notion of the *working directory*. This is where R looks for files when you ask it to load them by default. You can find out the current working directory in RStudio by looking to the top of the console:

![See working directory](pics/see_working_directory.png)

In R code the working directory can be printed out by the `getwd()` function:

```{r Getting working directory}
getwd()
```

In RStudio the working directory for Rmarkdown files is always the directory containing the script itself. You can change it, but when knitting an output file, it will reset to the default.

For plain R scripts, the working directory can be changed using the `setwd()` function. You are advised to always set the working directory to the folder containing the script file. 
The menu in RStudio holds a convenient shortcut for this:

![Set working directory in RStudio](pics/set_working_directory.png)


# Reading data

R can read many data formats. It has some built-in abilities, but most of the formats come from additional packages. For example, you'll need to install and to load the `readxl` package to be able to read data from excel files.

```{r Read data from an Excel file }
library(readxl)
hotdogs <- read_excel('data/hotdogs.xlsx')
```

# Calling functions

R has many functions available to process your data. To call a function, you provide its name and a list of arguments.

```{r Call a function, named arguments}
?seq
# Provide arguments by name, the order doesn't matter
seq(from = 1, to = 10, by = 3)
```


```{r Call a function, positional arguments}
# Provide arguments by position
seq(1, 10, 3)
```


```{r Call a function, mix named and positional arguments}
# First argument is matched by position, two other - by name 
seq(1, by = 3, to = 10)
```

```{r Call a function, mix named and positional arguments 2}
# `to` argument is provided by name, note that it's not counted for positional arguments anymore
seq(to = 10, 1, 3)

```

Many functions have default values for arguments

```{r Call a function, default values for arguments}
# 'by' = 1 by default
seq(from = 1, to = 10)
```


Same method of calling can be used with any function. This can save a lot of typing, but makes your intentions less clear and can lead to errors.

```{r Make a plot, positional arguments}
library(ggplot2)
?ggplot
?geom_point
?aes
ggplot(hotdogs, aes(Calories, Sodium)) +
  geom_point(aes(color = Type)) +
  geom_smooth(method = 'lm', se = F)
```

# Using variables to store your data

Always store the parameters and the intermediate results of your computation in variables.

```{r Center calories content}
# Create a new numeric variable
mean_cal <- mean(hotdogs$Calories)
# Create a new variable (column in a data frame)
hotdogs$Calories_Centered <- hotdogs$Calories - mean_cal
head(hotdogs)

```


# Basic data types in R

The basic data types in R are numbers (integer and real), text (chraracter) and boolean (logical).

```{r Data types}
# Double
typeof(2)

# Integer
typeof(2L)

# Character
typeof("Hello")

# Boolean
typeof(TRUE)
typeof(T) # TRUE and FALSE can be abbreviated

```

Most data in R live in the form of *objects*. An object has a *class* which determines how it is processed. Objects can be stored in variables and manipulated.

```{r Objects}
g <- last_plot()
class(g)
g + labs(title = 'Foods with more calories tend to be more salty')
```

# Data structures

To hold collections of related data R uses *vectors*, *lists* and *data frames*.

## Vectors
### Creating vectors
Vectors are arrays of values of the same data type. You can create a vector by concatenation (`c()` function).


```{r Creating a vector by concatenation}
# Creating a numeric vector by concatenation:
(v <- c(1, 2, -3, 4, 5)) # use () to get the assignment's result printed
typeof(v)
str(v)

# Creating a character vector
(my_colors <- c('red', 'green', 'blue'))
str(my_colors)
```

```{r Other ways to create a vector}
# Using sequence to create a vector
w <- 1:10
str(w)

# Controlling step size
(y <- seq(10, 1, -2)) 
str(y)

# Repeating a value
(my_characters <- rep('a', 5))
```

```{r Using a function to create a vector}
# Using a function
set.seed(1)
(r <- runif(5))

```

```{r Creating a logical vector by using a comparison}
# Creating a logical vector by comparison
(gt_05 <- r > 0.5)
```

```{r Extracting a column from data frame}
Calories <- hotdogs$Calories
str(Calories)
```

### Subsetting vectors

```{r Subsetting a vector}
# Subsetting a vector
Calories[1] #extracting a single element
Calories[2:3] #subset, contiguous elements
Calories[c(1,2,4,1)] #subset, non-contiguous elements
Calories[Calories > 180 & Calories < 190] # by logical indexing

```

### Computing with vectors

```{r Computing with vectors}
median(Calories) # all data in a vector is processed at once

(v1 <- rep(c(1, 2, 3), 2))
v1 ^ 2 # Vectorized operation

v1 - c(1, 2, 3) # the shorter vector is 'recycled'
#v1 - c(1, 2, 3, 4) # error, vectors sizes are not proportional
```

### Missing data
Data in the wild has usually some values missing. In R, a `NA` value is used to represent missing (unknown) data. Most operations with `NA` will result in a `NA`.

```{r Operations with missing data}
good <- 1 ; bad <- NA ; ugly <- NA

# Arithmetic
good + bad

# Comparisons
good > bad
bad == ugly

bad == NA
good == NA

is.na(bad) # use this to check for NA

```

NA cause most aggregation functions to produce NA. But most such functions have an argument to exclude NAs explicitly.

```{r Omitting NAs when aggregating data}
(d <- 1:5)
d[3] <- NA

mean(d) # won't work
mean(d, na.rm = T)

```

## Lists

Lists are collections of elements of any type. 

### Creating lists
```{r Indexed list example}
(indexed_list <- list(1, c(1, 2, 0), my_colors))
```

```{r Named list example}
(named_list <- list(first = 1, 
                    second = c(1, 2, 0), 
                    another_one = my_colors))
```

### Subsetting lists

You can extract elements from a list by index or by name (if it's available).

```{r Extracting list elements}
# By index
indexed_list[2] # produces a single-element list
indexed_list[[2]] # extracts the element itself

# By name
named_list$second # extracts the element itself
named_list['second'] # creates a single-element list
named_list[2] # named lists also work with indices
```

### Computing with lists

Lists do not support 'vectorized' computation unlike vectors. But R has facilities to process them.

```{r Processing lists}
# Apply a function to each element of a list
lapply(named_list, FUN = typeof)
```

### Lists and objects
The most important role of lists in R is the use of them for object representation. Objects, returned by various functions are internally represented as lists. You can extract elements from them in the same way as for lists.

```{r Creating a linear model}
# Create a linear regression model and store it in a variable
(m <- lm(Sodium ~ Calories, data = hotdogs))

```

```{r See whats inside}
# How is it represented?
class(m)
typeof(m)

# See what named elements are available
names(m) # use str(m) to explore the full structure

# Extract coefficients
m$coefficients

```

## Data frames
In base R, the structure to hold tabular data is `data.frame`. It can be viewed as a two-dimensional table or as a list of vectors of the same length. 

### Creating a data frame
Usually, the data frames are loaded from the external files. You can also create a data frame by stitching together a few vectors of the same length.

```{r Data frame creation}
# Create some fake data
N <- 20
id <- 1:N

# simulate weight data - N normal random numbers
set.seed(1)
weight <- round(rnorm(N, mean = 70, sd =7))

# simulate height data
height <- round(weight + runif(N, min = 90, max = 120))

# Assemble a data frame
people <- data.frame(person_id = id, weight, height)
head(people)

```

### Viewing a data frame

```{r Viewing a data frame}
people #entire data frame, works bad outside of RStudio
head(people, 3) #3 first rows
tail(people, 5) #5 last rows
#View(people) #open as a spreadsheet in RStudio
```

### Exploring structure
```{r Exploring a data frame structure}
# Explore a structure
class(people)
typeof(people)
str(people)

# Dimensions
length(people) #wrong: returns the last dimension
nrow(people) #number of rows
ncol(people) #number of columns
```

### Subsetting a data frame
Data frames elements can be extracted similarly to vectors and lists. But data frames are two-dimensional structures

```{r Extracting columns}
# What columns are available?
names(people)

# Extracting columns by name
people$weight
people['weight']

# Extracting columns by index
people[2] # Creates a 1-column data frame
people[[2]] # Extracts a vector 
```

The indexing order for data frames is [rows, columns]. You can extract parts of data frame by providing a specific range of indices for each dimension.

```{r Subsetting a data frame}
# First 3 rows
people[1:3, ]

# The first, and the third column
people[, c(1, 3)]

# First 5 rows, columns 2 and 3
people[1:5, 2:3]

# Remove the 2nd column:
people[-2] # to remove multiple columns use -c(1, 3)

```

**Warning** Using index-based subsetting is unsafe if data can change. Use name based subsetting and filtering provided by `dplyr` package instead.

## Tibbles

Tibbles are a nicer implementation of data frames provided by the `tibble` package. Tibble is a preferred data type for packages in "tidyverse". 


### Create a tibble
You can create tibbles in the same way as data frames, but using `tibble(...)` instead of `data.frame(...)`.

You can also convert type between tibble and dataframe by using the `as_tibble()` or `as.data.frame()` functions. 

```{r Convert a data frame to a tibble}
people_t <- tibble::as_tibble(people)
people_t
class(people_t)
```

You are avised to work with tibbles. You may need to convert a tibble to a data frame for compatibility with older functions, that can't operate on tibbles.
